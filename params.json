{"name":"Ghostman","tagline":"a search algorithm's demo","body":"\r\n##写在前面\r\n \r\n - 这是一个关于搜索算法的演示程序，它并不是一个软件，也没有任何商业用途\r\n - 它并不是在linux下开发的而是在windows下进行开发的。\r\n - 你可以随意下载该演示程序的代码，但是仅供学习，请勿用于任何商业用途\r\n\r\n##具体算法\r\n - 该算法演示程序主要包括以下几个算法\r\n    - 深度优先搜索算法（DFS）\r\n    - 广度优先搜索算法（BFS）\r\n    - A星算法（A*）\r\n    - 迭代加深的A星算法（IDA*）\r\n    - 蚁群算法（ACO）\r\n\r\n##让我先来测试一下代码好了##\r\n```cpp\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nint maze[ 10 ][ 10 ], t;\r\nint limit;\r\n\r\nbool check(){\r\n\tbool flag = true;\r\n\tfor( int i = 1; i <= 4; ++i ){\r\n\t\tfor( int j = 1; j < 4; ++j ){\r\n\t\t\tif( maze[i][j] != maze[i][4] ){\r\n\t\t\t\tflag = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\t\r\n\t\t}\r\n\t\tif( flag == false ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif( flag == true ){\r\n\t\treturn true;\r\n\t}\r\n\tfor( int i = 1; i <= 4; ++i ){\r\n\t\tfor( int j = 1; j < 4; ++j ){\r\n\t\t\tif( maze[j][i] != maze[4][i] ){\r\n\t\t\t\tflag = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\t\r\n\t\t}\r\n\t\tif( flag == false ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\t\r\n\treturn flag;\r\n}\r\n\r\nint h(){\r\n\tint minn = 0;\r\n\tfor( int i = 1; i <= 4; ++i ){\t\t\r\n\t\tint a[ 5 ] = {0};\r\n\t\tfor( int j = 1; j <= 4; ++j ){\r\n\t\t\ta[ maze[i][j] ]++;\r\n\t\t}\r\n\t\tsort( a, a + 5 );\r\n\t\tminn = 4 - a[4];\r\n\t}\r\n\t\r\n\tfor( int i = 1; i <= 4; ++i ){\t\t\r\n\t\tint a[ 5 ] = {0};\r\n\t\tfor( int j = 1; j <= 4; ++j ){\r\n\t\t\ta[ maze[j][i] ]++;\r\n\t\t}\r\n\t\tsort( a, a + 5 );\r\n\t\tminn  = min( minn, 4 - a[4] );\r\n\t}\r\n\treturn minn;\r\n}\r\n\r\nvoid L( int r ){\r\n\tint t = maze[r][1];\r\n\tfor( int i = 1; i < 4; ++i ){\r\n\t\tmaze[r][i] = maze[r][i+1];\r\n\t}\r\n\tmaze[r][4] = t;\r\n}\r\n\r\nvoid R( int r ){\r\n\tint t = maze[r][4];\r\n\tfor( int i = 4; i >= 2; --i ){\r\n\t\tmaze[r][i] = maze[r][i-1];\r\n\t}\t\r\n\tmaze[r][1] = t;\r\n}\r\n\r\nvoid U( int c ){\r\n\tint t = maze[1][c];\r\n\tfor( int i = 1; i < 4; ++i ){\r\n\t\tmaze[i][c] = maze[i+1][c];\r\n\t}\t\r\n\tmaze[4][c] = t;\r\n}\r\n\r\nvoid D( int c ){\r\n\tint t = maze[4][c];\r\n\tfor( int i = 4; i >= 2; --i ){\r\n\t\tmaze[i][c] = maze[i-1][c];\r\n\t}\t\r\n\tmaze[1][c] = t;\r\n}\r\n\r\nbool dfs( int d ){\r\n\tif( d == limit ){\r\n\t\treturn check();\r\n\t}\r\n\tif( d + h() > limit ){\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tfor( int i = 1; i <= 4; ++i ){\r\n\t\tL( i );\r\n\t\tif( dfs( d + 1 ) ){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tR( i );\r\n\t}\r\n\tfor( int i = 1; i <= 4; ++i ){\r\n\t\tR( i );\r\n\t\tif( dfs( d + 1 ) ){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tL( i );\r\n\t}\r\n\tfor( int i = 1; i <= 4; ++i ){\r\n\t\tU( i );\r\n\t\tif( dfs( d + 1 ) ){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tD( i );\r\n\t}\r\n\tfor( int i = 1; i <= 4; ++i ){\r\n\t\tD( i );\r\n\t\tif( dfs( d + 1 ) ){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tU( i );\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool IDA_star(){\r\n\tlimit = 1;\r\n\twhile( true ){\r\n\t\tif( limit > 5 ){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif( dfs( 0 ) ){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tlimit++;\t\r\n\t}\r\n}\r\n\r\nint main(){\r\n\tscanf( \"%d\", &t );\r\n\twhile( t-- ){\r\n\t\tfor( int i = 1; i <= 4; ++i ){\r\n\t\t\tfor( int j = 1; j <= 4; ++j ){\r\n\t\t\t\tscanf( \"%d\", &maze[i][j] );\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( IDA_star() ){\r\n\t\t\tprintf( \"%d\\n\", limit );\r\n\t\t}else{\r\n\t\t\tputs( \"-1\" );\r\n\t\t}\r\n\t}\t\r\n\treturn 0;\r\n} \r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}